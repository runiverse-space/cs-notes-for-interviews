# 1장 디자인 패턴과 프로그래밍 패러다임

라이브러리나 프레임워크는 디자인 패턴을 기반으로 설계되어 있으며, 이를 통해 로직을 구성하는 방식에 대한 패러다임을 제공한다.

- 라이브러리: 공통 기능을 모듈화한 코드 집합이다.
- 프레임워크: 공통 기능을 모듈화하고 코드 구조와 설계 방식을 제시하는 틀이다.

프로그래밍 패러다임이란 문제를 해결하고 코드를 구조화하는 근본적인 사고방식이다.

- React → 선언형 컴포넌트 기반
- Vue → 반응형 데이터 중심
- Spring → 의존성 주입과 객체지향 설계 중심

즉, 이 프레임워크를 사용하면 어떤 방식으로 사고하고 구조를 잡아야 하는지에 대한 가이드라인을 제공한다.

## 1.1 디자인 패턴

디자인 패턴이란, 프로그램을 설계할 때 반복적으로 발생하는 문제를 객체 간의 상호 관계 등을 활용하여 해결할 수 있도록 정리한 재사용 가능한 설계 방법이다.

### 1.1.1 싱글톤 패턴

싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다. 인스턴스를 다른 모듈에 공유하며 사용하기 때문에 인스턴스 생성 비용이 줄어드는 장점이 있는 반면, 의존성이 높아진다는 단점이 있다.

- 자바스크립트의 싱글톤 패턴

자바스크립트에서 리터럴 { } 또는 new Object로 객체를 생성하면, 매번 새로운 메모리 공간에 새로운 객체가 만들어진다.

```jsx
const obj = {
  a: 27,
};
const obj2 = {
  a: 27,
};
console.log(obj === obj2); // false
```

일반적으로 `new` 를 호출하면 항상 새로운 객체가 만들어지고, `this` 는 새 객체를 가리킨다. 따라서 `a` 와 `b` 는 서로 다른 객체이다.

```jsx
class Foo {}
const a = new Foo();
const b = new Foo();
console.log(a === b); //false
```

싱글톤 패턴은 클래스에서 단 하나의 인스턴스만 생성하고, 이후 호출에서는 기존 인스턴스를 반환하도록 구현한다.

```jsx
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      // 기존 인스턴스가 없다면
      Singleton.instance = this; // 현재 객체(this)를 인스턴스로 저장
    }
    return Singleton.instance; // 있다면 기존 인스턴스를 반환
  }
  getInstance() {
    return this;
  }
}

const a = new Singleton();
const b = new Singleton();
console.log(a === b); // true
```

Singleton.instance라는 하나의 인스턴스를 가지는 Singleton 클래스를 구현한 모습이다. 이를 통해 a와 b는 같은 인스턴스를 참조하게 된다.

- 데이터베이스 연결 모듈

싱글톤 패턴은 데이터베이스 연결 모듈에 많이 쓰인다.

```jsx
const URL = "mongodb://localhost:27017/test";
const createConnection = (url) => ({ url: url });
class DB {
  constructor(url) {
    if (!DB.instance) {
      DB.instance = createConnection(url);
    }
    return DB.instance;
  }
  connect() {
    return this.instance;
  }
}

const a = new DB(URL);
const b = new DB(URL);
console.log(a === b); // true
```

1. 첫 번째 호출: `DB.instance` 가 없으므로 `createConnection(url)` 결과를 저장하여 새 객체 생성
2. 두 번째 호출: `DB.instance`가 이미 존재하므로, 새 객체 대신 기존 객체를 반환

즉, `new` 를 여러 번 호출해도 생성자 내부에서 기존 인스턴스를 반환하면 같은 객체를 참조하게 된다.

- 자바에서의 싱글톤 패턴

자바로는 다음과 같이 중첩 클래스를 이용해서 만드는 방법이 가장 대중적이다.

```java
class Singleton {
    private static class singleInstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return singleInstanceHolder.INSTANCE;
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton a = Singleton.getInstance();
        Singleton b = Singleton.getInstance();
        System.out.println(a.hashCode());
        System.out.println(b.hashCode());
        if (a == b) {
            System.out.println(true);
        }
    }
}
```

- mongoose의 싱글톤 패턴

Node.js에서 MongoDB 데이터베이스를 연결할 때 쓰는 mongoose 모듈에서 볼 수 있다. mongoose의 데이터베이스를 연결할 때 쓰는 connect()라는 함수는 싱글톤 인스턴스를 반환한다.

```java
Mongoose.prototype.connect = function (uri, options, callback) {
  const _mongoose = this instanceof Mongoose ? this : mongoose;
  const conn = _mongoose.connection;

  return _mongoose._promiseOrCallback(callback, cb => {
    conn.openUri(uri, options, err => {
      if (err != null) {
        return cb(err);
      }
      return cb(null, _mongoose);
    });
  });
};
```

> 현재(6.x 이상) Mongoose에서는 해당 싱글톤 패턴을 그대로 사용할 수 없다

- MySQL의 싱글톤 패턴

Node.js에서 MySQL 데이터베이스를 연결할 때도 싱글톤 패턴이 쓰인다.

```java
// 메인 모듈
const mysql = require('mysql');
const pool = mysql.createPool({
  connectionLimit: 10,
  host: 'example.org',
  user: 'user',
  password: 'secret',
  database: '디비',
});

pool.connect();

// 모듈 A
pool.query(query, function (error, results, fields) {
  if (error) throw error;
  console.log('The solution is: ', results[0].solution);
});

// 모듈 B
pool.query(query, function (error, results, fields) {
  if (error) throw error;
  console.log('The solution is: ', results[0].solution);
});
```

데이터베이스 연결에 관한 인스턴스를 정의하고 해당 인스턴스를 기반으로 쿼리를 보내는 형식으로 쓰인다.

- 싱글톤 패턴의 단점

TDD에서 단위 테스트는 서로 독립적이어야 하지만, 싱글톤은 미리 생성된 하나의 인스턴스를 재활용하는 패턴이므로 독립적인 인스턴스를 만들기 어렵다.

**의존성 주입(DI, Dependency Injection) 정리**

- 장점: 모듈 교체가 쉽고, 테스트·마이그레이션에 유리하며, 추상화 기반 구조로 의존성 방향이 일관된다.
- 단점: 모듈 분리로 복잡성이 늘고, 약간의 런타임 성능 저하가 발생할 수 있다.
- 원칙
  - 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다
  - 둘 다 추상화에 의존해야 하며, 추상화는 세부 사항에 의존하지 말아야 한다.

### 1.1.2 팩토리 패턴

팩토리 패턴(factory pattern)은 객체 생성 로직을 분리하여 상위 클래스는 공통 구조만 정의하고, 하위 클래스가 구체적인 생성 방식을 결정하는 패턴이다. 이를 통해 상위 클래스는 객체 생성 방식에 의존하지 않으므로 결합도가 낮아지고, 유연성과 유지 보수성이 향상된다.

- 자바스크립트의 팩토리 패턴

자바스크립트는 new Object()를 사용하면 입력값에 따라 다른 타입의 객체를 생성하기 때문에 간단하게 팩토리 패턴처럼 구현할 수 있다.

```jsx
const num = new Object(42);
const str = new Object("abc");
num.constructor.name;
str.constructor.name;
```

커피 팩토리를 기반으로 라떼 등을 생산하는 코드를 구축해본다.

```jsx
class CoffeeFactory {
  static createCoffee(type) {
    const factory = factoryList[type];
    return factory.createCoffee();
  }
}

class Latte {
  constructor() {
    this.name = "Latte";
  }
}

class Espresso {
  constructor() {
    this.name = "Espresso";
  }
}

class LatteFactory extends CoffeeFactory {
  static createCoffee() {
    return new Latte();
  }
}

class EspressoFactory extends CoffeeFactory {
  static createCoffee() {
    return new Espresso();
  }
}

const factoryList = { LatteFactory, EspressoFactory };

const main = () => {
  // 라떼를 주문한다
  const coffee = CoffeeFactory.createCoffee("LatteFactory");
  // 커피 이름을 부른다
  console.log(coffee.name);
};

main();
```

`CoffeeFactory` 라는 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스인 `LatteFactory` 가 구체적인 내용을 결정한다.

또한, `static` 키워드를 통해 `createCoffee()` 메서드를 정적 메서드로 정의하면 클래스를 기반으로 객체를 생성하지 않고 호출이 가능하며, 해당 메서드는 한 번만 메모리에 할당된다.

- 자바의 팩토리 패턴

이를 자바로 구현하면 다음과 같다.

```java
enum CoffeeType {
    LATTE,
    ESPRESSO
}

abstract class Coffee {
    protected String name;

    public String getName() {
        return name;
    }
}

class Latte extends Coffee {
    public Latte() {
        name = "Latte";
    }
}

class Espresso extends Coffee {
    public Espresso() {
        name = "Espresso";
    }
}

class CoffeeFactory {
    public static Coffee createCoffee(CoffeeType type) {
        switch (type) {
            case LATTE:
                return new Latte();
            case ESPRESSO:
                return new Espresso();
            default:
                throw new IllegalArgumentException("Invalid coffee type: " + type);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Coffee coffee = CoffeeFactory.createCoffee(CoffeeType.LATTE);
        System.out.println(coffee.getName());
    }
}
```

1. `enum CoffeeType`
   - 커피의 종류를 상수(enum)으로 정의했다
2. `abstract class Coffee`
   - 추상 클래스 `Coffee` 는 모든 컾의 부모 클래스이며, 추상 클래스는 직접 객체를 생성할 수 없다.
   - name이라는 필드를 가지고 있으며, getName() 메서드로 커피 이름을 반환한다.
3. `Latte`, `Espresso` 클래스는 각각 `Coffee` 를 상속받아 구현된 구체적인 클래스이다.
   - 생성자에서 name 값을 각각 `"Latte"`, `"Espresso"` 로 설정한다.
4. CoffeeFactory (팩토리 클래스)
   - 객체 생성 로직을 한곳에서 관리한다.
   - `createCoffee()` 정적 메서드를 통해 `CoffeeType`에 따라 커피 객체를 생성한다.
5. Main 클래스
   - `CoffeeFactory.createCoffee(CoffeeType.LATTE)` 를 호출하려 `Latte` 객체를 생성한다.
   - `coffee.getName()` 을 호출하면 `"Latte"` 가 호출된다.

이 코드는 팩토리 패턴을 이용해 enum으로 커피 종류를 지정하고, 그에 맞는 객체를 생성하는 구조이다.

- Enum

상수의 집합을 정의하고 사용하는 클래스로 그 자체가 하나의 클래스이다. 또한 필드, 메서드, 생성자까지 가질 수 있는 객체 지향적인 상수 집합이다.

```java
enum CoffeeType {
    LATTE,
    ESPRESSO
}
```

enum을 사용하는 방법은 선언된 상수들을 `.` 연산자로 접근하여 사용한다.

```java
CoffeeType type = CoffeeType.LATTE;
```

또한 필드, 메서드, 생성자까지 가질 수 있는 객체 지향적인 상수 집합이다.

```java
enum CoffeeType {
    LATTE("라떼", 4000),
    ESPRESSO("에스프레소", 3000);

    private final String coffeeName;
    private final int price;

    CoffeeType(String coffeeName, int price) {
        this.coffeeName = coffeeName;
        this.price = price;
    }

    public String getCoffeeName() {
        return coffeeName;
    }

    public int getPrice() {
        return price;
    }
}

public class Main {
    public static void main(String[] args) {
        CoffeeType coffee = CoffeeType.LATTE;
        System.out.println(coffee.getCoffeeName() + " : " + coffee.getPrice() + "원");
    }
}
```

> [참고) Java Enum 활용기](https://techblog.woowahan.com/2527/)

### 1.1.3 전략 패턴

전략 패턴(Strategy Pattern)은 정책 패턴(Policy Pattern)이라고도 하며, 객체의 행위를 변경하고 싶을 때 직접 수정하지 않고, 알고리즘이나 행위를 전략(strategy)이라는 객체로 캡슐화하여 컨텍스트(Context) 안에서 교체 가능하게 만드는 패턴이다.

- 자바의 전략 패턴

```java
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

interface PaymentStrategy {
    public void pay(int amount);
}

class KAKAOCardStrategy implements PaymentStrategy {
    private String name;
    private String cardNumber;
    private String cvv;
    private String dateOfExpiry;

    public KAKAOCardStrategy(String nm, String ccNum, String cvv, String expiryDate) {
        this.name = nm;
        this.cardNumber = ccNum;
        this.cvv = cvv;
        this.dateOfExpiry = expiryDate;
    }

    @Override
    public void pay(int amount) {
        System.out.println(amount +
                " paid using KAKAOCard.");
    }
}

class LUNACardStrategy implements PaymentStrategy {
    private String emailId;
    private String password;

    public LUNACardStrategy(String email, String pwd) {
        this.emailId = email;
        this.password = pwd;

    }

    @Override
    public void pay(int amount) {
        System.out.println(amount + " paid using LUNACard.");
    }
}

class Item {
    private String name;
    private int price;

    public Item(String name, int cost) {
        this.name = name;
        this.price = cost;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return price;
    }
}

class ShoppingCart {
    List<Item> items;

    public ShoppingCart() {
        this.items = new ArrayList<Item>();
    }

    public void addItem(Item item) {
        this.items.add(item);
    }

    public void removeItem(Item item) {
        this.items.remove(item);
    }

    public int calculateTotal() {
        int sum = 0;
        for (Item item : items) {
            sum += item.getPrice();
        }
        return sum;
    }

    public void pay(PaymentStrategy paymentMethod) {
        int amount = calculateTotal();
        paymentMethod.pay(amount);
    }

}

public class HelloWorld {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        Item A = new Item("kundolA", 100);
        Item B = new Item("kundolB", 300);
        cart.addItem(A);
        cart.addItem(B);

        cart.pay(new KAKAOCardStrategy("Ju hongchul",
                "123456789", "123", "12/01"));
    }
}
```

이 코드는 쇼핑 카트에 아이템을 담아 LUNACard 또는 KAKAOCard라는 두개의 전략으로 결제하는 코드이다.

> 컨텍스트는 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말한다.

- passport의 전략 패턴

전략 패턴을 활용한 라이브러리로는 [passport](https://www.passportjs.org/)가 있다. passport는 Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 가지 ‘전략’을 기반으로 인증할 수 있게 한다.

```jsx
var passport = require("passport"),
  LocalStrategy = require("passport-local").Strategy;

passport.use(
  new LocalStrategy(function (username, password, done) {
    User.findOne({ username: username }, function (err, user) {
      if (err) {
        return done(err);
      }
      if (!user) {
        return done(null, false, { message: "Incorrect username." });
      }
      if (!user.validPassword(password)) {
        return done(null, false, { message: "Incorrect password." });
      }
      return done(null, user);
    });
  })
);
```

`passport.use()` 라는 메서드에 전략을 매개변수로 넣어서 로직을 수행한다.

### 1.1.4 옵저버 패턴

옵저버 패턴(observer pattern)은 객체(subject)의 상태 변화가 있을 때, 등록된 옵저버들에게 자동으로 통지하여 변화를 알려주는 디자인 패턴이다. 또한, 옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC(Model-View-Controller) 패턴에도 사용된다. 예를 들어 모델(model)에서 변경 사항이 생겨 update() 메서드로 옵저버인 뷰(view)에 알려주고 이를 기반으로 컨트롤러(controller) 등이 작동하는 것이다.

- 자바에서의 옵저버 패턴

```jsx
import java.util.ArrayList;
import java.util.List;

interface Subject {
    public void register(Observer obj);

    public void unregister(Observer obj);

    public void notifyObservers();

    public Object getUpdate(Observer obj);
}

interface Observer {
    public void update();
}

class Topic implements Subject {
    private List<Observer> observers;
    private String message;

    public Topic() {
        this.observers = new ArrayList<>();
        this.message = "";
    }

    @Override
    public void register(Observer obj) {
        if (!observers.contains(obj)) observers.add(obj);
    }

    @Override
    public void unregister(Observer obj) {
        observers.remove(obj);
    }

    @Override
    public void notifyObservers() {
        this.observers.forEach(Observer::update);
    }

    @Override
    public Object getUpdate(Observer obj) {
        return this.message;
    }

    public void postMessage(String msg) {
        System.out.println("Message sended to Topic: " + msg);
        this.message = msg;
        notifyObservers();
    }
}

class TopicSubscriber implements Observer {
    private String name;
    private Subject topic;

    public TopicSubscriber(String name, Subject topic) {
        this.name = name;
        this.topic = topic;
    }

    @Override
    public void update() {
        String msg = (String) topic.getUpdate(this);
        System.out.println(name + ":: got message >> " + msg);
    }
}

public class HelloWorld {
    public static void main(String[] args) {
        Topic topic = new Topic();
        Observer a = new TopicSubscriber("a", topic);
        Observer b = new TopicSubscriber("b", topic);
        Observer c = new TopicSubscriber("c", topic);
        topic.register(a);
        topic.register(b);
        topic.register(c);

        topic.postMessage("amumu is op champion!");
    }
}
```

`class Topic implements Subject`를 통해 `Subject interface` 를 구현했고 `Observer a = new TopicSubscriber("a", topic);` 으로 옵저버를 선언할 때 해당 이름과 어떠한 토픽의 옵저버가 될 것인지를 정한다.

- 상속과 구현의 특징과 차이

**상속(extends)**

상속은 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용하며 자식 클래스에서 추가 및 확장을 할 수 있다. 이로 인해 재사용성, 중복성의 최소화가 이루어진다.

**구현(implements)**

구현은 부모 인터페이스(interface)를 자식 클래스에서 재정의하여 구현하는 것을 말하며, 상속과는 달리 반드시 부모 클래스의 메서드를 재정의하여 구현해야 한다.

**상속과 구현의 차이**

상속은 일반 클래스, abstract 클래스를 기반으로 구현하며, 구현은 인터페이스를 기반으로 구현한다.

- 자바스크립트에서의 옵저버 패턴

자바스크립트에서의 옵저버 패턴은 프록시 객체를 통해 구현할 수 있다.

**프록시 객체**

프록시(proxy) 객체는 어떠한 대상의 기본적인 동작 작업을 가로챌 수 있는 객체를 뜻하며, 두 개의 매개변수를 가진다.

- target: 프록시할 대상

- handler: target 동작을 가로채고 어떠한 동작을 할 것인지 설정되어 있는 함수

```jsx
const handler = {
  get: function (target, name) {
    return name === "name" ? `${target.a} ${target.b}` : target[name];
  },
};
const p = new Proxy({ a: "Hello World", b: "in Java!" }, handler);
console.log(p.name); // Hello world in Java!
```

1. `get: function (원래 객체, 접근하려는 속성 이름)` 메서드는 속성을 읽을 때 호출되는 함수이다. 만약 읽으려는 속성이 `name` 이면 a와 b를 합친 문자열을 반환하고, 아니라면 원래 속성 값을 반환한다.
2. `const p = new Proxy({ a: 'Hello World', b: 'in Java!' }, handler);` Proxy 객체 p를 생성하고, 첫 번째 인자: 원래 객체(target), 두 번째 인자: handler(가로채는 로직)로 접근을 가로채서 원하는 로직을 실행한다.

이렇게 name 속성 등 특정 속성에 접근할 때 그 부분을 가로채서 어떠한 로직을 강제할 수 있는 것이 프록시 객체이다.

**프록시 객체를 이용한 옵저버 패턴**

```jsx
function createReactiveObject(target, callback) {
  const proxy = new Proxy(target, {
    set(obj, prop, value) {
      if (value !== obj[prop]) {
        const prev = obj[prop];
        obj[prop] = value;
        callback(`${prop}는 [${prev}] >> [${value}]로 변경되었습니다.`);
      }
      return true;
    },
  });
  return proxy;
}

const a = {
  너: "솔로",
};
const b = createReactiveObject(a, console.log);
b.너 = "솔로";
b.너 = "커플";
```

프록시 객체의 get() 함수는 속성과 함수에 대한 접근을 가로채며, set() 함수를 통해 속성에 대한 접근을 가로채서 너라는 속성이 솔로에서 커플로 되는것을 감시할 수 있다.

- Vue.js 3.0의 옵저버 패턴

Vue.js 3.0에서 ref나 reactive로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경된다.

> DOM(Document Object Model)
> 문서 객체 모델을 말하며, 웹 브라우저상의 화면을 이루고 있는 요소들을 지칭한다.

```jsx
function createReactiveObject(target: Target, isReadonly: boolean, baseHandlers: ProxyHandler<any>, collectionHandlers: ProxyHandler<any>, proxyMap: WeakMap<Target, any>) {
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }

  if (target[ReactiveFlags.RAW] && !(isReadonly && target[ReactiveFlags.IS_REACTIVE])) {
    return target;
  }

  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }

  const targetType = getTargetType(target);
  if (targetType === TargetType.INVALID) {
    return target;
  }

  const proxy = new Proxy(target, targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
```

Vue.js 3.0의 옵저버 패턴이 담긴 코드이다. proxyMap이라는 프록시 객체를 사용했고, 객체 내부의 get(), set() 메서드를 사용했다.

### 1.1.5 프록시 패턴과 프록시 서버

프록시 객체는 디자인 패턴 중 하나인 프록시 패턴이 녹아들어 있는 객체이다.

- 프록시 패턴 (proxy pattern)

프록시 패턴은 대상 객체(subject)에 접근하기 전에 그 접근을 가로채 흐름을 제어하는 디자인 패턴이다. 이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다. 프록시 객체로 쓰이기도 하며 프록시 서버로도 활용된다.

> 프록시 서버에서의 캐싱
> 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것을 말한다. 불필요한 외부 연결이 없기 때문에 트래픽을 줄일 수 있다.

- 프록시 서버(proxy server)

프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.

**프록시 서버로 쓰는 nginx**

nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이다. nginx를 프록시 서버로 둬서 실제 포트를 숨길 수 있고 정적 자원을 gzip 압축하거나, 메인 서버 앞단에서의 로깅을 할 수도 있다.

> gzip 압축
> LZ77과 Huffman 코딩의 조합인 DEFLATE 알고리즘을 기반으로 한 압축 기술이다. gzip 압축을 하면 데이터 전송량을 줄일 수 있지만, 압축을 해제했을 때 서버에서의 CPU 오버헤드도 생각해서 gzip의 압축 사용 유무를 결정해야 한다.

**프록시 서버로 쓰는 CloudFlare**

CloudFlare는 전 세계에 분산된 서버를 통해 시스템의 콘텐츠를 빠르게 전달하는 CDN 서비스이다. 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 쓰인다.

서비스 배포 이후 해외에서 의심스러운 트래픽이 많이 발생하면 이때 CloudFlare가 의심스러운 트래픽인지 먼저 판단해 CAPTCHA 등을 기반으로 일정 부분 막아주는 역할도 수행한다.

- DDOS 공격 방어

    CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단해서 DDOS 공격으로부터 보호한다. CloudFlare의 거대한 네트워크 용량과 캐싱 전략으로 소규모 DDOS 공격은 쉽게 막아낼 수 있으며 이러한 공격에 대한 방화벽 대시보드도 제공한다.

DDOS는 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형이다.

- HTTPS 구축

서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수 있으며, CloudFlare를 사용하면 별도의 인증서 설치 없이 쉽게 HTTPS를 구축할 수 있다.

> CDN(Content Delivery Network)
> 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다.

**CORS와 프런트엔드의 프록시 서버**

CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.

> 오리진
> 프로토콜과 호스트 이름, 포트의 조합을 말한다. 예를 들어 https://localhost:8080/test 라는 주소에서 오리진은 https://localhost:8080 을 뜻한다.

### 1.1.6 이터레이터 패턴

이터레이터 패턴은 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴이다. 순회할 수 있는 여러 가지 자료형의 구조와 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능하다.

```jsx
const mp = new Map();
mp.set("a", 1);
mp.set("b", 2);
mp.set("c", 3);
const st = new Set();
st.add(1);
st.add(2);
st.add(3);
for (let a of mp) console.log(a);
for (let a of st) console.log(a);
```

다른 자료 구조인 set과 map임에도 똑같은 for a of b 라는 이터레이터 프로토콜을 통해 순회하는 것을 볼 수 있다.

### 1.1.7 노출모듈 패턴

노출모듈 패턴(revealing module pattern)은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말한다.

자바스크립트는 private나 public같은 접근 제어자가 존재하지 않고 전역 범위에서 실행되기 때문에 노출모듈 패턴을 통해 private와 public 접근 제어자를 구현하기도 한다.

```jsx
const example = (() => {
  // private
  const a = 1;
  const b = () => 2;

  // public
  const c = 3;
  const d = () => 4;

  return {
    c,
    d,
  };
})();

console.log(example.c); // 3
console.log(example.d()); // 4
console.log(example.a); // undefined (private)
console.log(example.b); // undefined (private)
```

a와 b는 다른 모듈에서 사용할 수 없는 변수나 함수이며 private 범위를 가진다. c와 d는 public 범위를 가진다.

- public:
클래스에 정의된 함수에서 접근 가능하며 자식 클래스와 외부 클래스에서 접근 가능한 범위

- protected:
클래스에 정의된 함수에서 접근 가능, 자식 클래스에서 접근 가능하지만 외부 클래스에서 접근 불가능한 범위

- private:
클래스에 정의된 함수에서 접근 가능하지만 자식 클래스와 외부 클래스에서 접근 불가능한 범위

- 즉시 실행 함수:
함수를 정의하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용한다

### 1.1.8 MVC 패턴

MVC 패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴이다. 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 각각의 구성 요소에만 집중해서 개발할 수 있다.

- 모델

모델(model)은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻한다. 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신한다.

- 뷰

뷰(view)는 사용자 인터페이스 요소를 나타낸다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻한다. 또한, 변경이 일어나면 컨트롤러에 이를 전달해야 한다.

- 컨트롤러

컨트롤러(controller)는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다. 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려준다.

- MVC 패턴의 예 스프링

MVC 패턴을 이용한 대표적인 프레임워크로는 스프링(spring)이 있다. 스프링의 WEB MVC는 웹 서비스를 구축하는 데 편리한 기능등을 제공한다. 예를 들어 @RequestParam, @Path Variable 등의 애너테이션을 기반으로 사용자의 요청 값들을 쉽게 분석할 수 있으며 재사용 가능한 코드, 테스트, 리디렉션 등의 장점이 있다.

### 1.1.9 MVP 패턴

MVP 패턴은 MVC 패턴으로부터 파생되었으며 MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴이다. 뷰와 프레젠터는 일대일 관계이기 때문에 강한 결합을 지닌 디자인 패턴이라고 볼 수 있다.

### 1.1.10 MVVM 패턴

MVVM 패턴은 MVC의 C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴이다. MVVM 패턴은 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있도 단위 테스팅하기 쉽다.

- MVVM 패턴의 예: 뷰

MVVM 패턴을 가진 대표적인 프레임워크로는 뷰(Vue.js)가 있다. Vue.js는 반응형(reactivity)이 특징인 프런트엔드 프레임워크로, watch와 computed 등으로 쉽게 반응형적인 값들을 구축할 수 있다.

함수를 사용하지 않고 값 대입만으로도 변수가 변경되며 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있다. 또한, 재사용 가능한 컴포넌트 기반으로 UI를 구성할 수 있다.

> 데이터 바인딩은 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.
